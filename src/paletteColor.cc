/*
 * Copyright (C) 2023  Ferdous,S M <ferdous.csebuet@egmail.com>
 * Author: Ferdous,S M <ferdous.csebuet@egmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "ClqPart/paletteCol.h"
#include <iostream>

//This function is slightly modified from generated by chatGpt
bool findFirstCommonElement(const std::vector<NODE_T>& vec1, const std::vector<NODE_T>& vec2) {
    int i = 0; // Index for vec1
    int j = 0; // Index for vec2

    while (i < vec1.size() && j < vec2.size()) {
        if (vec1[i] < vec2[j]) {
            i++; // Move to the next element in vec1
        } else if (vec1[i] > vec2[j]) {
            j++; // Move to the next element in vec2
        } else {
            return true; // Found a common element
        }
    }

    return false; // No common element found
}

void PaletteColor::buildStreamConfGraph ( NODE_T eu, NODE_T ev) {

  std::vector<NODE_T> v(colList[eu].size());
  std::vector<NODE_T>::iterator it;

  //it = std::set_intersection(colList[eu].begin(),colList[eu].end(),
  //  colList[ev].begin(),colList[ev].end(),v.begin());  

  //v.resize(it - v.begin());
  bool hasCommon = findFirstCommonElement(colList[eu],colList[ev]);
  if(hasCommon == true ) {

    confAdjList[eu].push_back(ev); 
    confAdjList[ev].push_back(eu); 
    nConflicts++;
    //if(e.u == 0) std::cout<<e.v<<" ";
    //confVertices[e.u]++;
    //confVertices[e.v]++;
  }

}


void PaletteColor::assignListColor() {

  double t1 = omp_get_wtime();
  std::mt19937 engine(2034587);
  std::uniform_int_distribution<NODE_T> uniform_dist(0, colThreshold-1);
  
  //NODE_T T =  3*static_cast<NODE_T> (log(n));
  //NODE_T T = 8;

  std::cout<<"Assigning random color " << colThreshold<<" "<<T<<std::endl;
  
  std::vector<bool> isPresent(colThreshold);
  for (NODE_T i= 0; i<n ; i++) {
    std::fill(isPresent.begin(),isPresent.end(),false);
    for (NODE_T j=0; j<T ; j++) {
      NODE_T col;
      do {
        col = uniform_dist(engine);
      }while(isPresent[col] == true);

      colList[i].push_back(col); 
      isPresent[col] = true;
      //if ( i== 0 || i == 6660) std::cout<<colList[i][j]<<" ";
    } 
    //if ( i== 0 || i == 6660) std::cout<<std::endl;
    std::stable_sort(colList[i].begin(),colList[i].end());
  }
  assignTime = omp_get_wtime() - t1;
  std::cout<<"Assignment of Color Time: "<<assignTime<<std::endl;

}
void PaletteColor::orderConfVertices() {
   
  std::vector<NODE_T > degreeConf(n,0);

  for(NODE_T i=0;i<n;i++) {
    degreeConf[i]= confAdjList[i].size(); 
  }
  std::iota(vertexOrder.begin(),vertexOrder.end(),0);

  std::stable_sort(vertexOrder.begin(),vertexOrder.end(),
      [&degreeConf] (NODE_T t1, NODE_T t2) {return degreeConf[t1] > degreeConf[t2];});


}

void PaletteColor::populateCandColors( NODE_T u, std::vector<NODE_T> &candColors) {
  for(auto v:confAdjList[u] ) {
    if (confColors[v] !=  -1) {
      candColors[ confColors[v] ] = u; 
    } 
  }
}

NODE_T PaletteColor::firstAvailColor( NODE_T u, std::vector<NODE_T> &candColors) {
  for(NODE_T v=0;v < candColors.size(); v++ ) {
    if ( candColors[v] != u) {
      return v; 
    } 
  }
  return -1;
}
void PaletteColor::greedyColor(NODE_T offset) {
  std::vector<NODE_T> candColors(n,-1);
 
  for(auto u:invalidVertices ) {
    //std::cout<<u<<std::endl;
    populateCandColors(u,candColors); 
    
    confColors[u] = firstAvailColor(u,candColors);
    colors[u] = confColors[u]+offset;
  }
}

NODE_T PaletteColor::attemptToColor(NODE_T vtx) {

  /*bool flag = false;
  for(auto colInd = 0;colInd<colList[vtx].size();colInd++) {
    flag = true;
    auto col = colList[vtx].at(colInd);
    std::cout<<"attempting to color with: "<<col<<std::endl;
    for(auto v:confAdjList[vtx]) {
      if (colors[v] == col) {
        flag = false;
        break; 
      }
    }     
    if(flag == true) {
      std::cout<<"succeded to color"<<std::endl;
      colors[vtx] = col;
      return colInd; 
    }
  }
  
  return -1;
  */

  std::mt19937 engine(213857);
  std::uniform_int_distribution<NODE_T> uniform_dist(0,colList[vtx].size()-1);

  auto colInd = uniform_dist(engine);
  
  auto col = colList[vtx].at(colInd);
  colors[vtx] = col;
  return colInd;
}

void PaletteColor::confColor() {
  
  std::cout<<"conflicting edges: "<<nConflicts<<std::endl; 
  orderConfVertices();
  for(NODE_T i:vertexOrder) {
    if(confAdjList[i].empty() == false) {
      for(auto col:colList[i]) {
        bool flag = true;
        for(auto v:confAdjList[i]) {
          if (colors[v] == col) {
            flag = false;
            break; 
          }
        }     

        if(flag == true) {
          colors[i] = col;
          break; 
        }
      }  
      if(colors[i] == -1)
        invalidVertices.push_back(i);
    } 
    else
      colors[i] = colList[i][0];
    //std::cout<<i<<" "<<colors[i]<<std::endl;
  }
  NODE_T maxCol = *std::max_element(colors.begin(),colors.end()) + 1;
  std::cout<<"# of vertices can not be colored: "<<invalidVertices.size()
    <<std::endl;
  greedyColor(maxCol);
  nColors = *std::max_element(colors.begin(),colors.end()) + 1;
}

void PaletteColor::fixBuckets(NODE_T vtx, NODE_T col, NODE_T &vtxProcessed, 
    std::vector< std::vector<NODE_T> > &verBucket, std::vector<NODE_T> &verLoc, NODE_T &vMin) {
  for( auto v:confAdjList[vtx] ) {
    if(colors[v] == -1) {
      auto it = std::find(colList[v].begin(),colList[v].end(),col);
      if(it != colList[v].end()) {
        //fix the location of the last vertex 
        verLoc[verBucket[colList[v].size()-1].back()] = verLoc[v];
        //now swap v with last element
        std::swap(verBucket[colList[v].size()-1][verLoc[v]],verBucket[colList[v].size()-1].back());
        //remove v from this bucket
        verBucket[colList[v].size()-1].pop_back();
        
        //swap the colr with last color
        std::swap(*it,colList[v].back());
        //remove the color
        colList[v].pop_back(); 
        if(colList[v].empty() == true) {
          vtxProcessed++;
          invalidVertices.push_back(v);
          colors[v] = -2;
        }
        else {
          if (colList[v].size() < vMin) 
            vMin = colList[v].size();

          verBucket[colList[v].size()-1].push_back(v); 
          verLoc[v] = verBucket[colList[v].size()-1].size()-1;
        }
      }
      
    }
  } 

  
}

void PaletteColor::confColorGreedy() {
  
  double t1 = omp_get_wtime();
  std::cout<<"conflicting edges: "<<nConflicts<<std::endl; 
  //Buckets of size T;
  std::vector<std::vector<NODE_T> > verBucket(T+1);
  //to stoe the position of vertex in the corresponding bucket
  std::vector<NODE_T> verLocation(n);
  
  NODE_T vMin = T; 

  std::mt19937 engine(2034587);
  std::uniform_int_distribution<NODE_T> uniform_dist(0, colThreshold-1);

  //# of verties processed. For stopping condition later
  NODE_T vtxProcessed = 0;
  for(NODE_T i=0;i<n;i++) {
    //if this is a non-conflicting vertex we can color it arbitrarily from the 
    //list of colors.
    if(confAdjList[i].empty() == true) {
      //std::cout<<"coloring non-conflicting edge"<<std::endl;
      uniform_dist = std::uniform_int_distribution<NODE_T>(0, 
          colList[i].size()-1);
      colors[i] = colList[i][uniform_dist(engine)];
      vtxProcessed++;
      continue;
    }
    //otherwise place it in appropriate bucket
    NODE_T t = colList[i].size();
    verBucket[t-1].push_back(i); 
    verLocation[i] = verBucket[t-1].size()-1;
    
    //the minimum bucket length
    if(t < vMin) {
      vMin = t; 
    }
  }
  std::cout<<"The minimum bucket size is: "<<vMin<<std::endl;
 
  //keep processing until we see all the vertices. 
  while (vtxProcessed < n) {
    for(NODE_T i = vMin-1; i < T;i++) {
      //if this bucket has elements
      //select a random vertex and swap it with the last element
      //to efficiently remove this vertex from the bucket.
      //std::cout<<"Bucket: "<<i<<"size: "<<verBucket[i].size()<<std::endl;
      if(verBucket[i].empty() == false) {
        uniform_dist = std::uniform_int_distribution<NODE_T>(0, 
            verBucket[i].size()-1);
        NODE_T selectedVtxLoc = uniform_dist(engine);
        NODE_T selectedVtx = verBucket[i].at(selectedVtxLoc);

        //update the verLocation array of the last element
        verLocation[verBucket[i].back()] = selectedVtxLoc;
        
        //swap the vertex with the last element
        std::swap(verBucket[i][selectedVtxLoc],verBucket[i].back());
        //remove the vertex
        verBucket[i].pop_back();

        //attempt to color this vertex
        NODE_T colInd = attemptToColor(selectedVtx);
        if(colInd>=0) {
          //remove col at colInd of the vtx is not necessary
          //std::swap(colList[selectedVtx][colInd],colList[selectedVtx].back());
          //colList[selectedVtx].pop_back();

          fixBuckets(selectedVtx,colors[selectedVtx],vtxProcessed,verBucket,verLocation,vMin); 
          //std::cout<<"updated VMin: "<<vMin<<std::endl;
        }
        else {
          colors[selectedVtx] = -2;
          invalidVertices.push_back(selectedVtx); 
        }
        vtxProcessed++;
        break;
      } 
    }
  }
  std::cout<<"# of vertices can not be colored: "<<invalidVertices.size()
    <<std::endl;

  
  NODE_T invalid = 0;
  for(NODE_T i=0;i<n;i++) {
    if(colors[i] == -2)
     invalid++; 
  }
  std::cout<<invalid<<std::endl;
  confColorTime = omp_get_wtime() - t1;
  
  std::cout<<"Conflict Coloring Time: "<<confColorTime<<std::endl;

}


