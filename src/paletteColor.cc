/*
 * Copyright (C) 2023  Ferdous,S M <ferdous.csebuet@egmail.com>
 * Author: Ferdous,S M <ferdous.csebuet@egmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "ClqPart/paletteCol.h"
#include <iostream>

//This function is slightly modified from generated by chatGpt
bool findFirstCommonElement(const std::vector<NODE_T>& vec1, const std::vector<NODE_T>& vec2) {
    int i = 0; // Index for vec1
    int j = 0; // Index for vec2

    while (i < vec1.size() && j < vec2.size()) {
        if (vec1[i] < vec2[j]) {
            i++; // Move to the next element in vec1
        } else if (vec1[i] > vec2[j]) {
            j++; // Move to the next element in vec2
        } else {
            return true; // Found a common element
        }
    }

    return false; // No common element found
}

//This function checks whether the edge (eu,ev) (in complement graph) is a conflict. NOte that 
//this is for constructing the graph in streaming way, so we are presented with
//one edge at a time. (eu,ev) is an edge in a complement graph.
void PaletteColor::buildStreamConfGraph ( NODE_T eu, NODE_T ev) {

  bool hasCommon = findFirstCommonElement(colList[eu],colList[ev]);
  if(hasCommon == true ) {

    confAdjList[eu].push_back(ev); 
    confAdjList[ev].push_back(eu); 
    nConflicts++;
  }

}

#ifdef ENABLE_GPU
void PaletteColor::buildConfGraphGpu (ClqPart::JsonGraph &jsongraph) {
  std::vector<std::vector<uint32_t>> &pauliEnc = jsongraph.getEncodedData();
  pauliEncSize = pauliEnc[0].size();
  h_pauliEnc.resize(pauliEnc.size() * pauliEncSize);
  // Convert pauliEnc to 1d array and copy to GPU
  for (NODE_T i = 0; i < pauliEnc.size(); i++) {
    for (NODE_T j = 0; j < pauliEncSize; j++) {
      h_pauliEnc[i * pauliEncSize + j] = pauliEnc[i][j];
    }
  }
  cudaMalloc(&d_pauliEnc, h_pauliEnc.size() * sizeof(NODE_T));
  cudaMemcpy(d_pauliEnc, h_pauliEnc.data(), h_pauliEnc.size() * sizeof(NODE_T), cudaMemcpyHostToDevice);

  h_confOffsets.resize(n);
  cudaMalloc(&d_confOffsets, h_confOffsets.size() * sizeof(NODE_T));
  h_confVertices.resize(n * n);
  cudaMalloc(&d_confVertices, h_confVertices.size() * sizeof(NODE_T));

  cudaDeviceSynchronize();

  // Create d_nConflicts and initialize to 0
  NODE_T *d_nConflicts;
  cudaMalloc(&d_nConflicts, sizeof(NODE_T));
  cudaMemset(d_nConflicts, 0, sizeof(NODE_T));

  // Call function to send to GPU to build conf graph
  buildConfGraphDevice(d_pauliEnc, pauliEncSize, d_colList, n, T, d_confOffsets, d_confVertices, d_nConflicts);
  cudaDeviceSynchronize();
  // Read d_nConflicts from GPU
  cudaMemcpy(&nConflicts, d_nConflicts, sizeof(NODE_T), cudaMemcpyDeviceToHost);
  // Print nConflicts
  nConflicts /= 2;
  // Copy h_confOffsets and h_confVertices from GPU
  cudaMemcpy(h_confOffsets.data(), d_confOffsets, h_confOffsets.size() * sizeof(NODE_T), cudaMemcpyDeviceToHost);
  cudaMemcpy(h_confVertices.data(), d_confVertices, h_confVertices.size() * sizeof(NODE_T), cudaMemcpyDeviceToHost);

  cudaDeviceSynchronize();
  std::cout << "nConflicts: " << nConflicts << std::endl;
  // Exit program
  for(NODE_T i = 0; i < n; i++) {
    confAdjList[i].reserve(h_confOffsets[i]);
    for(NODE_T j = 0; j < h_confOffsets[i]; j++) {
      confAdjList[i].push_back(h_confVertices[i * n + j]);
    }
    std::sort(confAdjList[i].begin(), confAdjList[i].end());
  }
}
#endif // ENABLE_GPU

//This function assign random list of colors from the Palette.
void PaletteColor::assignListColor() {

  std::mt19937 engine(2034587);
  std::uniform_int_distribution<NODE_T> uniform_dist(0, colThreshold-1);
  
  //We want the colors to be not repeating. Thus initially the list size is
  //same for each vertex
  std::vector<bool> isPresent(colThreshold);

  std::cout<<"Assigning random list color " << "Palette Size: "<<colThreshold
            <<" "<<"List size: "<<T<<std::endl;
  
  double t1 = omp_get_wtime();
  for (NODE_T i= 0; i<n ; i++) {
    std::fill(isPresent.begin(),isPresent.end(),false);
    for (NODE_T j=0; j<T ; j++) {
      NODE_T col;
      do {
        col = uniform_dist(engine);
      }while(isPresent[col] == true);

      colList[i].push_back(col); 
      isPresent[col] = true;
    } 
    std::stable_sort(colList[i].begin(),colList[i].end());
  }
  #ifdef ENABLE_GPU
  std::cout << "Sending to GPU" << std::endl;
  // Convert colList to 1d array and copy to GPU
  h_colList.resize(colList.size() * T);
  for (NODE_T i = 0; i < colList.size(); i++) {
    for (NODE_T j = 0; j < T; j++) {
      h_colList[i * T + j] = colList[i][j];
    }
  }
  // Copy h_colList to GPU
  cudaError_t err;
  err = cudaMalloc(&d_colList, h_colList.size() * sizeof(NODE_T));
  err = cudaMemcpy(d_colList, h_colList.data(), h_colList.size() * sizeof(NODE_T), cudaMemcpyHostToDevice);
  if (err != cudaSuccess) {
    std::cout << "Error: " << cudaGetErrorString(err) << std::endl;
  }
  #endif // ENABLE_GPU
  assignTime = omp_get_wtime() - t1;
  std::cout<<"Assignment Time: "<<assignTime<<std::endl;

}

//This function sort the vertices of the conflict graph w.r.t to their degrees.
//The idea is to color the vertex with highest degree first, since this represents
//the most conflicted with other vertices. Does not perform that well in practice.
//We are not using it at the moment.
void PaletteColor::orderConfVertices() {
   
  std::vector<NODE_T > degreeConf(n,0);

  for(NODE_T i=0;i<n;i++) {
    degreeConf[i]= confAdjList[i].size(); 
  }
  std::iota(vertexOrder.begin(),vertexOrder.end(),0);

  std::stable_sort(vertexOrder.begin(),vertexOrder.end(),
      [&degreeConf] (NODE_T t1, NODE_T t2) {return degreeConf[t1] > degreeConf[t2];});


}

/********************************************************************************
//The next three functions are not necessary at this moment. They are used to color
//the invalid vertices. But since we do not know the subgraph induced by the invalid
//vertices coloring them only with conflict graph is wrong.  
void PaletteColor::populateCandColors( NODE_T u, std::vector<NODE_T> &candColors) {
  for(auto v:confAdjList[u] ) {
    if (confColors[v] !=  -1) {
      candColors[ confColors[v] ] = u; 
    } 
  }
}

NODE_T PaletteColor::firstAvailColor( NODE_T u, std::vector<NODE_T> &candColors) {
  for(NODE_T v=0;v < candColors.size(); v++ ) {
    if ( candColors[v] != u) {
      return v; 
    } 
  }
  return -1;
}
void PaletteColor::greedyColor(NODE_T offset) {
  std::vector<NODE_T> candColors(n,-1);
 
  for(auto u:invalidVertices ) {
    //std::cout<<u<<std::endl;
    populateCandColors(u,candColors); 
    
    confColors[u] = firstAvailColor(u,candColors);
    colors[u] = confColors[u]+offset;
  }
}
********************************************************************************/

//The function given a vtx, properly color the vertx using a random color from the list.
//the coloring is guaranteed but I first name it attempt. kept in this way.
NODE_T PaletteColor::attemptToColor(NODE_T vtx) {

  std::mt19937 engine(213857);
  std::uniform_int_distribution<NODE_T> uniform_dist(0,colList[vtx].size()-1);

  auto colInd = uniform_dist(engine);
  
  auto col = colList[vtx].at(colInd);
  colors[vtx] = col;
  return colInd;
}

//This function attempt to color the conflicting graph with largest degree heuristics.
//Does not perform well
void PaletteColor::confColor() {
  
  std::cout<<"conflicting edges: "<<nConflicts<<std::endl; 
  orderConfVertices();
  for(NODE_T i:vertexOrder) {
    if(confAdjList[i].empty() == false) {
      for(auto col:colList[i]) {
        bool flag = true;
        for(auto v:confAdjList[i]) {
          if (colors[v] == col) {
            flag = false;
            break; 
          }
        }     

        if(flag == true) {
          colors[i] = col;
          break; 
        }
      }  
      if(colors[i] == -1)
        invalidVertices.push_back(i);
    } 
    else
      colors[i] = colList[i][0];
    //std::cout<<i<<" "<<colors[i]<<std::endl;
  }
  std::cout<<"# of vertices can not be colored: "<<invalidVertices.size()
    <<std::endl;
  nColors = *std::max_element(colors.begin(),colors.end()) + 1;
}



//The next two functions fixBuckets and ConfColorGreedy are needed for coloring
//the conflict graph. This heuristic color the vertices with the smallest list size
//first, since they have less options. Works well in practice. 
void PaletteColor::fixBuckets(NODE_T vtx, NODE_T col, NODE_T &vtxProcessed, 
    std::vector< std::vector<NODE_T> > &verBucket, std::vector<NODE_T> &verLoc, NODE_T &vMin) {
  for( auto v:confAdjList[vtx] ) {
    if(colors[v] == -1) {
      auto it = std::find(colList[v].begin(),colList[v].end(),col);
      if(it != colList[v].end()) {
        //fix the location of the last vertex 
        verLoc[verBucket[colList[v].size()-1].back()] = verLoc[v];
        //now swap v with last element
        std::swap(verBucket[colList[v].size()-1][verLoc[v]],verBucket[colList[v].size()-1].back());
        //remove v from this bucket
        verBucket[colList[v].size()-1].pop_back();
        
        //swap the colr with last color
        std::swap(*it,colList[v].back());
        //remove the color
        colList[v].pop_back(); 
        if(colList[v].empty() == true) {
          vtxProcessed++;
          invalidVertices.push_back(v);
          colors[v] = -2;
        }
        else {
          if (colList[v].size() < vMin) 
            vMin = colList[v].size();

          verBucket[colList[v].size()-1].push_back(v); 
          verLoc[v] = verBucket[colList[v].size()-1].size()-1;
        }
      }
      
    }
  } 

  
}

void PaletteColor::confColorGreedy() {
  
  double t1 = omp_get_wtime();
  std::cout<<"# of conflicting edges: "<<nConflicts<<std::endl; 
  //Buckets of size T;
  std::vector<std::vector<NODE_T> > verBucket(T+1);
  //to stoe the position of vertex in the corresponding bucket
  std::vector<NODE_T> verLocation(n);
  
  NODE_T vMin = T; 

  std::mt19937 engine(2034587);
  std::uniform_int_distribution<NODE_T> uniform_dist(0, colThreshold-1);

  //# of verties processed. For stopping condition later
  NODE_T vtxProcessed = 0;
  for(NODE_T i=0;i<n;i++) {
    //if this is a non-conflicting vertex we can color it arbitrarily from the 
    //list of colors.
    if(confAdjList[i].empty() == true) {
      //std::cout<<"coloring non-conflicting edge"<<std::endl;
      uniform_dist = std::uniform_int_distribution<NODE_T>(0, 
          colList[i].size()-1);
      colors[i] = colList[i][uniform_dist(engine)];
      vtxProcessed++;
      continue;
    }
    //otherwise place it in appropriate bucket
    NODE_T t = colList[i].size();
    verBucket[t-1].push_back(i); 
    verLocation[i] = verBucket[t-1].size()-1;
    
    //the minimum bucket length
    if(t < vMin) {
      vMin = t; 
    }
  }
 
  //keep processing until we see all the vertices. 
  while (vtxProcessed < n) {
    for(NODE_T i = vMin-1; i < T;i++) {
      //if this bucket has elements
      //select a random vertex and swap it with the last element
      //to efficiently remove this vertex from the bucket.
      //std::cout<<"Bucket: "<<i<<"size: "<<verBucket[i].size()<<std::endl;
      if(verBucket[i].empty() == false) {
        uniform_dist = std::uniform_int_distribution<NODE_T>(0, 
            verBucket[i].size()-1);
        NODE_T selectedVtxLoc = uniform_dist(engine);
        NODE_T selectedVtx = verBucket[i].at(selectedVtxLoc);

        //update the verLocation array of the last element
        verLocation[verBucket[i].back()] = selectedVtxLoc;
        
        //swap the vertex with the last element
        std::swap(verBucket[i][selectedVtxLoc],verBucket[i].back());
        //remove the vertex
        verBucket[i].pop_back();

        //attempt to color this vertex
        NODE_T colInd = attemptToColor(selectedVtx);
        if(colInd>=0) {
          //remove col at colInd of the vtx is not necessary
          //std::swap(colList[selectedVtx][colInd],colList[selectedVtx].back());
          //colList[selectedVtx].pop_back();

          fixBuckets(selectedVtx,colors[selectedVtx],vtxProcessed,verBucket,verLocation,vMin); 
          //std::cout<<"updated VMin: "<<vMin<<std::endl;
        }
        else {
          colors[selectedVtx] = -2;
          invalidVertices.push_back(selectedVtx); 
        }
        vtxProcessed++;
        break;
      } 
    }
  }
  std::cout<<"# of invalid vertices: "<<invalidVertices.size()
    <<std::endl;

 /* 
  NODE_T invalid = 0;
  for(NODE_T i=0;i<n;i++) {
    if(colors[i] == -2)
     invalid++; 
  }
  std::cout<<invalid<<std::endl;
  */

  confColorTime = omp_get_wtime() - t1;
  
  std::cout<<"Conflict Coloring Time: "<<confColorTime<<std::endl;

  nColors = *std::max_element(colors.begin(),colors.end()) + 1;

}




